import {
  Document,
  Packer,
  Paragraph,
  TextRun,
  HeadingLevel,
  Header,
  Footer,
  AlignmentType,
  PageBreak,
} from 'docx';

export interface DocSection {
  title: string;
  content: string | string[];
  level?: 1 | 2 | 3;
}

export interface DOCXOptions {
  title: string;
  subtitle?: string;
  author?: string;
}

export async function generateDOCX(
  sections: DocSection[],
  options: DOCXOptions
): Promise<Blob> {
  const children: Paragraph[] = [];

  // Title
  children.push(
    new Paragraph({
      text: options.title,
      heading: HeadingLevel.TITLE,
      alignment: AlignmentType.CENTER,
      spacing: { after: 400 },
    })
  );

  if (options.subtitle) {
    children.push(
      new Paragraph({
        alignment: AlignmentType.CENTER,
        spacing: { after: 600 },
        children: [
          new TextRun({ text: options.subtitle, italics: true, size: 28 }),
        ],
      })
    );
  }

  // Page break after title (wrapped in paragraph)
  children.push(
    new Paragraph({
      children: [new PageBreak()],
    })
  );

  // Sections
  for (const section of sections) {
    const headingLevel =
      section.level === 1
        ? HeadingLevel.HEADING_1
        : section.level === 2
        ? HeadingLevel.HEADING_2
        : HeadingLevel.HEADING_3;

    children.push(
      new Paragraph({
        text: section.title,
        heading: headingLevel,
        spacing: { before: 400, after: 200 },
      })
    );

    const contentItems = Array.isArray(section.content)
      ? section.content
      : [section.content];

    for (const item of contentItems) {
      if (item && item.trim()) {
        children.push(
          new Paragraph({
            children: [new TextRun({ text: item, size: 24 })],
            spacing: { after: 200 },
          })
        );
      }
    }
  }

  const doc = new Document({
    creator: options.author || 'SwissVault AI',
    title: options.title,
    description: options.subtitle || '',
    sections: [
      {
        properties: {},
        headers: {
          default: new Header({
            children: [
              new Paragraph({
                alignment: AlignmentType.RIGHT,
                children: [
                  new TextRun({
                    text: options.title,
                    size: 20,
                    color: '666666',
                  }),
                ],
              }),
            ],
          }),
        },
        footers: {
          default: new Footer({
            children: [
              new Paragraph({
                alignment: AlignmentType.CENTER,
                children: [
                  new TextRun({
                    text: 'Generated by SwissVault AI',
                    size: 18,
                    color: '999999',
                  }),
                ],
              }),
            ],
          }),
        },
        children: children,
      },
    ],
  });

  return await Packer.toBlob(doc);
}

export function downloadDOCX(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename.endsWith('.docx') ? filename : `${filename}.docx`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

export async function uploadDOCX(
  blob: Blob,
  userId: string,
  filename: string,
  supabase: any
): Promise<string | null> {
  try {
    const filePath = `${userId}/documents/${filename}`;

    const { error } = await supabase.storage
      .from('agent-outputs')
      .upload(filePath, blob, {
        contentType:
          'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        upsert: true,
      });

    if (error) {
      console.error('Upload error:', error);
      return null;
    }

    const { data } = supabase.storage
      .from('agent-outputs')
      .getPublicUrl(filePath);

    return data.publicUrl;
  } catch (err) {
    console.error('Upload exception:', err);
    return null;
  }
}
