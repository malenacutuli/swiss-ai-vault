import PptxGenJS from 'pptxgenjs';

export interface SlideContent {
  title: string;
  content: string[];
  notes?: string;
  layout?: 'title' | 'content' | 'two-column' | 'image';
  imageUrl?: string;
}

export interface PPTXOptions {
  title: string;
  subtitle?: string;
  author?: string;
  company?: string;
  theme?: 'default' | 'dark' | 'swiss' | 'corporate';
}

const themes = {
  default: {
    background: 'FFFFFF',
    titleColor: '1F2937',
    textColor: '4B5563',
    accentColor: '0D9488',
  },
  dark: {
    background: '1F2937',
    titleColor: 'FFFFFF',
    textColor: 'D1D5DB',
    accentColor: '10B981',
  },
  swiss: {
    background: 'FFFFFF',
    titleColor: '1F2937',
    textColor: '4B5563',
    accentColor: 'DC2626',
  },
  corporate: {
    background: 'FFFFFF',
    titleColor: '1E3A5F',
    textColor: '374151',
    accentColor: '2563EB',
  },
};

export async function generatePPTX(
  slides: SlideContent[],
  options: PPTXOptions
): Promise<Blob> {
  const pptx = new PptxGenJS();
  const theme = themes[options.theme || 'default'];

  // Set presentation properties
  pptx.author = options.author || 'Ghost AI';
  pptx.company = options.company || 'Ghost';
  pptx.title = options.title;
  pptx.subject = options.subtitle || '';

  // Define master slide
  pptx.defineSlideMaster({
    title: 'GHOST_MASTER',
    background: { color: theme.background },
    objects: [
      // Footer with branding
      {
        text: {
          text: 'Generated by Ghost AI',
          options: {
            x: 0.5,
            y: '92%',
            w: '90%',
            h: 0.3,
            fontSize: 8,
            color: theme.textColor,
            align: 'right',
          },
        },
      },
    ],
  });

  // Create title slide
  const titleSlide = pptx.addSlide({ masterName: 'GHOST_MASTER' });
  titleSlide.addText(options.title, {
    x: 0.5,
    y: '35%',
    w: '90%',
    h: 1,
    fontSize: 44,
    bold: true,
    color: theme.titleColor,
    align: 'center',
  });

  if (options.subtitle) {
    titleSlide.addText(options.subtitle, {
      x: 0.5,
      y: '55%',
      w: '90%',
      h: 0.5,
      fontSize: 24,
      color: theme.textColor,
      align: 'center',
    });
  }

  // Create content slides
  for (const slideContent of slides) {
    const slide = pptx.addSlide({ masterName: 'GHOST_MASTER' });

    // Title
    slide.addText(slideContent.title, {
      x: 0.5,
      y: 0.5,
      w: '90%',
      h: 0.8,
      fontSize: 32,
      bold: true,
      color: theme.titleColor,
    });

    // Accent line under title
    slide.addShape(pptx.ShapeType.rect, {
      x: 0.5,
      y: 1.3,
      w: 1.5,
      h: 0.05,
      fill: { color: theme.accentColor },
    });

    // Content based on layout
    if (slideContent.layout === 'two-column' && slideContent.content.length > 1) {
      // Two column layout
      const midpoint = Math.ceil(slideContent.content.length / 2);
      const leftContent = slideContent.content.slice(0, midpoint);
      const rightContent = slideContent.content.slice(midpoint);

      // Left column
      slide.addText(
        leftContent.map(text => ({ text: '• ' + text, options: { bullet: false, breakLine: true } })),
        {
          x: 0.5,
          y: 1.8,
          w: '45%',
          h: 4,
          fontSize: 18,
          color: theme.textColor,
          valign: 'top',
        }
      );

      // Right column
      slide.addText(
        rightContent.map(text => ({ text: '• ' + text, options: { bullet: false, breakLine: true } })),
        {
          x: '52%',
          y: 1.8,
          w: '45%',
          h: 4,
          fontSize: 18,
          color: theme.textColor,
          valign: 'top',
        }
      );
    } else {
      // Standard bullet list
      slide.addText(
        slideContent.content.map(text => ({
          text: text,
          options: { bullet: { type: 'bullet', color: theme.accentColor }, breakLine: true },
        })),
        {
          x: 0.5,
          y: 1.8,
          w: '90%',
          h: 4,
          fontSize: 20,
          color: theme.textColor,
          valign: 'top',
        }
      );
    }

    // Add image if provided
    if (slideContent.imageUrl && slideContent.layout === 'image') {
      try {
        slide.addImage({
          path: slideContent.imageUrl,
          x: '55%',
          y: 1.8,
          w: 4,
          h: 3,
        });
      } catch (e) {
        console.warn('Failed to add image:', e);
      }
    }

    // Add speaker notes
    if (slideContent.notes) {
      slide.addNotes(slideContent.notes);
    }
  }

  // Generate the file
  const blob = await pptx.write({ outputType: 'blob' }) as Blob;
  return blob;
}

// Helper to download the generated PPTX
export function downloadPPTX(blob: Blob, filename: string = 'presentation.pptx'): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// Helper to upload generated PPTX to Supabase
export async function uploadPPTX(
  blob: Blob,
  userId: string,
  filename: string,
  supabase: any
): Promise<string | null> {
  try {
    const filePath = `${userId}/presentations/${filename}`;
    
    const { error } = await supabase.storage
      .from('agent-outputs')
      .upload(filePath, blob, {
        contentType: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
        upsert: true,
      });

    if (error) {
      console.error('Upload error:', error);
      return null;
    }

    const { data } = supabase.storage
      .from('agent-outputs')
      .getPublicUrl(filePath);

    return data.publicUrl;
  } catch (err) {
    console.error('Upload exception:', err);
    return null;
  }
}
