/**
 * SOAP Note Generator
 * Creates professional clinical documentation
 */

import type { CaseState, Message, SymptomEntity, Hypothesis } from '../types';

export interface SOAPNote {
  generatedAt: string;
  patientInfo: {
    age: number;
    sex: string;
    chiefComplaint: string;
  };
  subjective: {
    historyOfPresentIllness: string;
    associatedSymptoms: string[];
    negativeSymptoms: string[]; // Symptoms denied
    pastMedicalHistory: string[];
    medications: Array<{
      name: string;
      dose?: string;
      frequency?: string;
      reason?: string;
    }>;
    allergies: string[];
    socialHistory?: string;
    familyHistory?: string;
  };
  objective: {
    selfReportedFindings: string[];
    vitalSigns?: {
      bloodPressure?: string;
      heartRate?: string;
      temperature?: string;
      respiratoryRate?: string;
      oxygenSaturation?: string;
    };
    generalAppearance?: string;
    physicalExamFindings?: string[];
  };
  assessment: {
    clinicalImpression: string;
    differentialDiagnosis: Array<{
      condition: string;
      likelihood: 'most_likely' | 'likely' | 'possible' | 'less_likely';
      reasoning: string;
      icdCode?: string;
    }>;
    redFlags: string[];
    riskStratification?: string;
  };
  plan: {
    laboratoryTests: Array<{
      test: string;
      rationale: string;
    }>;
    imagingStudies: Array<{
      study: string;
      rationale: string;
    }>;
    diagnosticProcedures: Array<{
      procedure: string;
      indication: string;
    }>;
    management: string[];
    patientEducation: string[];
    followUp: string;
    referrals?: string[];
    urgency: 'emergent' | 'urgent' | 'semi_urgent' | 'routine';
  };
  disclaimer: string;
}

export function generateSOAPNote(caseState: CaseState): SOAPNote {
  const now = new Date().toISOString();

  // Extract symptoms
  const reportedSymptoms = caseState.symptom_entities
    .filter(s => s.present === true)
    .map(s => formatSymptom(s));

  const deniedSymptoms = caseState.symptom_entities
    .filter(s => s.present === false)
    .map(s => s.name);

  // Extract medications from medical history
  const medications = caseState.medications || [];
  const allergies = caseState.allergies || [];

  // Build differential diagnosis
  const differential = buildDifferentialDiagnosis(caseState.hypothesis_list);

  // Determine plan based on triage level and hypotheses
  const plan = buildPlan(caseState);

  return {
    generatedAt: now,
    patientInfo: {
      age: caseState.demographics?.age || 0,
      sex: caseState.demographics?.sex || 'Unknown',
      chiefComplaint: caseState.chief_complaint || 'Not specified',
    },
    subjective: {
      historyOfPresentIllness: buildHPI(caseState),
      associatedSymptoms: reportedSymptoms,
      negativeSymptoms: deniedSymptoms,
      pastMedicalHistory: caseState.medical_history?.conditions || [],
      medications: medications.map(m => ({
        name: m.name,
        dose: m.dosage,
        frequency: m.frequency,
        reason: m.reason,
      })),
      allergies: allergies,
      socialHistory: caseState.medical_history?.social_history,
      familyHistory: caseState.medical_history?.family_history?.join(', '),
    },
    objective: {
      selfReportedFindings: extractObjectiveFindings(caseState),
      generalAppearance: inferGeneralAppearance(caseState),
    },
    assessment: {
      clinicalImpression: buildClinicalImpression(caseState),
      differentialDiagnosis: differential,
      redFlags: caseState.red_flags.map(rf => rf.description),
      riskStratification: getRiskLevel(caseState.triage_level),
    },
    plan: plan,
    disclaimer: `This clinical summary was generated by an AI system (HELIOS) for informational purposes only. It does NOT constitute a medical diagnosis, treatment plan, or professional medical advice. All information should be verified by a licensed healthcare provider. The AI system may make errors or omissions. Always seek the advice of a qualified healthcare professional for any medical concerns.`,
  };
}

function formatSymptom(symptom: SymptomEntity): string {
  let description = symptom.name;

  if (symptom.duration) {
    description += ` for ${symptom.duration}`;
  }
  if (symptom.severity) {
    description += ` (${symptom.severity} severity)`;
  }
  if (symptom.location) {
    description += ` in ${symptom.location}`;
  }
  if (symptom.character) {
    description += `, described as ${symptom.character}`;
  }

  return description;
}

function buildHPI(caseState: CaseState): string {
  const age = caseState.demographics?.age || 'Unknown age';
  const sex = caseState.demographics?.sex || 'patient';
  const cc = caseState.chief_complaint || 'unspecified symptoms';

  // Find onset/duration from symptoms
  const primarySymptom = caseState.symptom_entities.find(s => s.present);
  const duration = primarySymptom?.duration || 'unspecified duration';

  let hpi = `${age}-year-old ${sex} presenting with ${cc}`;

  if (duration !== 'unspecified duration') {
    hpi += ` with onset ${duration} ago`;
  }

  // Add associated symptoms
  const associated = caseState.symptom_entities
    .filter(s => s.present && s.name !== caseState.chief_complaint)
    .map(s => s.name);

  if (associated.length > 0) {
    hpi += `. Associated symptoms include ${associated.join(', ')}`;
  }

  // Add character/quality descriptions
  const descriptions = caseState.symptom_entities
    .filter(s => s.present && s.character)
    .map(s => `${s.name} described as ${s.character}`);

  if (descriptions.length > 0) {
    hpi += `. Patient describes ${descriptions.join('; ')}`;
  }

  return hpi + '.';
}

function buildDifferentialDiagnosis(hypotheses: Hypothesis[]): SOAPNote['assessment']['differentialDiagnosis'] {
  // Sort by confidence
  const sorted = [...hypotheses].sort((a, b) => b.confidence - a.confidence);

  return sorted.slice(0, 5).map((h, index) => ({
    condition: h.name,
    likelihood: index === 0 ? 'most_likely'
      : index === 1 ? 'likely'
      : index < 4 ? 'possible'
      : 'less_likely',
    reasoning: h.supporting_evidence?.join('; ') || 'Based on clinical presentation',
    icdCode: h.icd_code,
  }));
}

function extractObjectiveFindings(caseState: CaseState): string[] {
  const findings: string[] = [];

  // Extract from symptom entities that have physical manifestations
  caseState.symptom_entities.forEach(s => {
    if (s.present && s.location) {
      findings.push(`${s.name} noted in ${s.location}`);
    }
    if (s.present && s.severity === 'severe') {
      findings.push(`Patient reports severe ${s.name}`);
    }
  });

  // Add any systemic symptoms
  const systemicSymptoms = caseState.symptom_entities.filter(s =>
    s.present && ['fever', 'chills', 'fatigue', 'weight loss', 'night sweats'].some(
      sys => s.name.toLowerCase().includes(sys)
    )
  );

  if (systemicSymptoms.length > 0) {
    findings.push(`Reports systemic symptoms: ${systemicSymptoms.map(s => s.name).join(', ')}`);
  }

  return findings;
}

function inferGeneralAppearance(caseState: CaseState): string {
  // Based on red flags and severity
  if (caseState.red_flags.some(rf => rf.severity === 'critical')) {
    return 'Patient may appear acutely ill based on reported symptoms';
  }
  if (caseState.triage_level === 'ESI1' || caseState.triage_level === 'ESI2') {
    return 'Clinical presentation suggests urgency; patient should be evaluated promptly';
  }
  return 'Patient appears stable based on self-reported information';
}

function buildClinicalImpression(caseState: CaseState): string {
  const age = caseState.demographics?.age || 'Unknown age';
  const sex = caseState.demographics?.sex || 'patient';
  const cc = caseState.chief_complaint || 'symptoms';

  const topHypothesis = caseState.hypothesis_list[0];

  let impression = `${age}-year-old ${sex} with ${cc}`;

  if (topHypothesis) {
    impression += `, concerning for ${topHypothesis.name}`;

    if (caseState.hypothesis_list.length > 1) {
      impression += ` with differential including ${caseState.hypothesis_list.slice(1, 3).map(h => h.name).join(', ')}`;
    }
  }

  if (caseState.red_flags.length > 0) {
    impression += `. Notable for ${caseState.red_flags.length} red flag finding(s) requiring urgent evaluation`;
  }

  return impression + '.';
}

function getRiskLevel(triageLevel?: string): string {
  switch (triageLevel) {
    case 'ESI1': return 'Critical - Immediate evaluation required';
    case 'ESI2': return 'High - Emergent evaluation needed';
    case 'ESI3': return 'Moderate - Urgent evaluation recommended';
    case 'ESI4': return 'Low-Moderate - Semi-urgent evaluation';
    case 'ESI5': return 'Low - Routine evaluation appropriate';
    default: return 'Not formally stratified';
  }
}

function buildPlan(caseState: CaseState): SOAPNote['plan'] {
  const plan: SOAPNote['plan'] = {
    laboratoryTests: [],
    imagingStudies: [],
    diagnosticProcedures: [],
    management: [],
    patientEducation: [],
    followUp: '',
    urgency: 'routine',
  };

  // Determine urgency
  if (caseState.triage_level === 'ESI1' || caseState.triage_level === 'ESI2') {
    plan.urgency = 'emergent';
  } else if (caseState.triage_level === 'ESI3') {
    plan.urgency = 'urgent';
  } else if (caseState.triage_level === 'ESI4') {
    plan.urgency = 'semi_urgent';
  }

  // Add standard labs based on presentation
  const hasInfectionConcern = caseState.symptom_entities.some(s =>
    s.present && ['fever', 'swelling', 'infection', 'discharge'].some(
      t => s.name.toLowerCase().includes(t)
    )
  );

  if (hasInfectionConcern) {
    plan.laboratoryTests.push(
      { test: 'Complete Blood Count (CBC)', rationale: 'Evaluate for infection or hematologic process' },
      { test: 'Erythrocyte Sedimentation Rate (ESR)', rationale: 'Assess for underlying inflammation' },
      { test: 'C-Reactive Protein (CRP)', rationale: 'Marker of acute inflammation or infection' }
    );
  }

  // Add imaging based on location
  const affectedLocations = caseState.symptom_entities
    .filter(s => s.present && s.location)
    .map(s => s.location!.toLowerCase());

  if (affectedLocations.some(loc => loc.includes('chest'))) {
    plan.imagingStudies.push({
      study: 'Chest X-ray',
      rationale: 'Evaluate pulmonary and cardiac structures'
    });
  }

  if (affectedLocations.some(loc => loc.includes('abdomen'))) {
    plan.imagingStudies.push({
      study: 'Abdominal ultrasound or CT',
      rationale: 'Evaluate abdominal structures and potential pathology'
    });
  }

  if (affectedLocations.some(loc => loc.includes('axilla') || loc.includes('armpit') || loc.includes('lymph'))) {
    plan.imagingStudies.push({
      study: 'Ultrasound of affected area',
      rationale: 'Evaluate lymph node architecture and tissue consistency'
    });
    plan.diagnosticProcedures.push({
      procedure: 'Consider excisional biopsy',
      indication: 'If imaging reveals suspicious lymph nodes'
    });
  }

  // Add management recommendations
  plan.management.push(
    'No immediate medications pending diagnostic workup',
    'Treatment to be guided by diagnostic findings',
    'Address stress management, sleep, and dietary intake to improve overall health'
  );

  // Patient education
  plan.patientEducation.push(
    'Return precautions discussed',
    'Signs and symptoms requiring immediate medical attention reviewed',
    'Importance of follow-up emphasized'
  );

  // Follow-up based on urgency
  switch (plan.urgency) {
    case 'emergent':
      plan.followUp = 'Immediate physician evaluation required';
      break;
    case 'urgent':
      plan.followUp = 'Physician evaluation within 24-48 hours recommended';
      break;
    case 'semi_urgent':
      plan.followUp = 'Physician evaluation within 1 week recommended';
      break;
    default:
      plan.followUp = 'Routine follow-up with primary care provider';
  }

  return plan;
}

// Format SOAP note as text for display
export function formatSOAPNoteAsText(soap: SOAPNote): string {
  let text = '';

  text += `SOAP Note\n`;
  text += `Generated: ${new Date(soap.generatedAt).toLocaleString()}\n\n`;

  text += `Subjective\n`;
  text += `• ${soap.subjective.historyOfPresentIllness}\n`;

  if (soap.subjective.associatedSymptoms.length > 0) {
    soap.subjective.associatedSymptoms.forEach(s => {
      text += `• ${s}\n`;
    });
  }

  if (soap.subjective.negativeSymptoms.length > 0) {
    text += `• Denies ${soap.subjective.negativeSymptoms.join(', ')}\n`;
  }

  if (soap.subjective.pastMedicalHistory.length > 0) {
    text += `• Past medical history: ${soap.subjective.pastMedicalHistory.join(', ')}\n`;
  } else {
    text += `• No history of infections, injuries, surgeries or chronic medical conditions\n`;
  }

  if (soap.subjective.medications.length > 0) {
    soap.subjective.medications.forEach(m => {
      text += `• Medication: ${m.name}${m.dose ? ` ${m.dose}` : ''}${m.frequency ? ` ${m.frequency}` : ''}${m.reason ? ` for ${m.reason}` : ''}\n`;
    });
  }

  text += `• ${soap.subjective.allergies.length > 0 ? `Allergies: ${soap.subjective.allergies.join(', ')}` : 'No known allergies'}\n\n`;

  text += `Objective\n`;
  text += `• Self-reported findings:\n`;
  soap.objective.selfReportedFindings.forEach(f => {
    text += `  ◦ ${f}\n`;
  });

  text += `\nAssessment\n`;
  text += `• Differential includes:\n`;
  soap.assessment.differentialDiagnosis.forEach(d => {
    text += `  ◦ ${d.condition}${d.icdCode ? ` (${d.icdCode})` : ''}\n`;
  });

  text += `\nPlan\n`;

  if (soap.plan.laboratoryTests.length > 0) {
    text += `• Laboratory Tests:\n`;
    soap.plan.laboratoryTests.forEach(t => {
      text += `  ◦ ${t.test} - ${t.rationale}\n`;
    });
  }

  if (soap.plan.imagingStudies.length > 0) {
    text += `• Imaging Studies:\n`;
    soap.plan.imagingStudies.forEach(s => {
      text += `  ◦ ${s.study} - ${s.rationale}\n`;
    });
  }

  if (soap.plan.diagnosticProcedures.length > 0) {
    text += `• Further Diagnostic Procedures:\n`;
    soap.plan.diagnosticProcedures.forEach(p => {
      text += `  ◦ ${p.procedure} - ${p.indication}\n`;
    });
  }

  text += `• Management:\n`;
  soap.plan.management.forEach(m => {
    text += `  ◦ ${m}\n`;
  });

  text += `\n${soap.disclaimer}\n`;

  return text;
}
