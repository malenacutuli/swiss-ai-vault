# Email Ingestion Pipeline: Malware Scanning Step

**From:** Manus Platform Technical Lead  
**Classification:** Internal Engineering Documentation  
**Purpose:** Exact pseudocode for malware scanning in email ingestion pipeline

---

## 1. Architecture Context

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    EMAIL INGESTION PIPELINE                                  │
└─────────────────────────────────────────────────────────────────────────────┘

┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│  SMTP    │───▶│ Validate │───▶│  Parse   │───▶│  SCAN    │───▶│  Queue   │
│ Receiver │    │  (SPF/   │    │ (Extract │    │(ClamAV)  │    │  (Agent  │
│          │    │  DKIM)   │    │  attach) │    │          │    │  Process)│
└──────────┘    └──────────┘    └──────────┘    └──────────┘    └──────────┘
                                                     │
                                                     │ This document
                                                     ▼
                                              ┌──────────────┐
                                              │ clamav-      │
                                              │ service:3310 │
                                              └──────────────┘
```

---

## 2. Data Structures

```python
# =============================================================================
# DATA STRUCTURES
# =============================================================================

from enum import Enum
from dataclasses import dataclass, field
from typing import Optional, List
from datetime import datetime
import uuid


class ScanStatus(Enum):
    """Possible outcomes of malware scan."""
    PENDING = "pending"           # Not yet scanned
    SCANNING = "scanning"         # Currently being scanned
    CLEAN = "clean"               # No malware detected
    INFECTED = "infected"         # Malware detected
    ERROR = "error"               # Scan failed (retryable)
    SKIPPED = "skipped"           # Scan skipped (encrypted, too large)
    TIMEOUT = "timeout"           # Scan timed out
    CONNECTION_ERROR = "conn_err" # Could not connect to scanner


class ScanErrorCode(Enum):
    """Error codes for scan failures."""
    NONE = "none"
    CONNECTION_REFUSED = "E001"
    CONNECTION_TIMEOUT = "E002"
    READ_TIMEOUT = "E003"
    WRITE_TIMEOUT = "E004"
    PROTOCOL_ERROR = "E005"
    SIZE_EXCEEDED = "E006"
    ENCRYPTED_FILE = "E007"
    CORRUPTED_FILE = "E008"
    SCANNER_OVERLOADED = "E009"
    DATABASE_NOT_LOADED = "E010"
    INTERNAL_ERROR = "E999"


class RetryDecision(Enum):
    """Decision after failure."""
    RETRY_IMMEDIATE = "retry_immediate"
    RETRY_BACKOFF = "retry_backoff"
    RETRY_DIFFERENT_HOST = "retry_different_host"
    SKIP_ATTACHMENT = "skip"
    REJECT_EMAIL = "reject"
    ALERT_AND_SKIP = "alert_skip"
    FAIL_PERMANENTLY = "fail"


@dataclass
class Attachment:
    """Email attachment to be scanned."""
    id: str
    email_id: str
    filename: str
    content_type: str
    size_bytes: int
    data: bytes
    checksum_sha256: str
    
    # Scan state
    scan_status: ScanStatus = ScanStatus.PENDING
    scan_attempts: int = 0
    last_scan_at: Optional[datetime] = None
    virus_name: Optional[str] = None
    error_code: Optional[ScanErrorCode] = None
    error_message: Optional[str] = None
    
    # Metadata
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)


@dataclass
class ScanResult:
    """Result of a single scan attempt."""
    status: ScanStatus
    virus_name: Optional[str] = None
    error_code: Optional[ScanErrorCode] = None
    error_message: Optional[str] = None
    duration_ms: float = 0.0
    scanner_host: Optional[str] = None
    retry_decision: RetryDecision = RetryDecision.FAIL_PERMANENTLY


@dataclass
class ScannerHealth:
    """Health status of a scanner host."""
    host: str
    port: int
    is_healthy: bool
    last_check: datetime
    consecutive_failures: int
    avg_latency_ms: float
    database_version: Optional[str] = None


@dataclass
class ScanContext:
    """Context for a scan operation."""
    attachment: Attachment
    attempt_number: int
    max_attempts: int
    start_time: datetime
    correlation_id: str
    scanner_hosts: List[str]
    current_host_index: int = 0
```

---

## 3. Configuration

```python
# =============================================================================
# CONFIGURATION
# =============================================================================

@dataclass
class ScannerConfig:
    """Configuration for malware scanner."""
    
    # Connection settings
    hosts: List[str] = field(default_factory=lambda: [
        "clamav-service.email-pipeline.svc.cluster.local"
    ])
    port: int = 3310
    
    # Timeouts (seconds)
    connect_timeout: float = 5.0
    read_timeout: float = 30.0
    write_timeout: float = 30.0
    total_timeout: float = 60.0
    
    # Retry settings
    max_retries: int = 3
    retry_delay_base: float = 1.0      # Base delay in seconds
    retry_delay_max: float = 30.0      # Maximum delay
    retry_jitter: float = 0.1          # Jitter factor (0-1)
    
    # Size limits
    max_file_size: int = 25 * 1024 * 1024  # 25MB
    chunk_size: int = 8192                  # 8KB chunks
    
    # Circuit breaker
    circuit_breaker_threshold: int = 5     # Failures before opening
    circuit_breaker_timeout: float = 60.0  # Seconds before half-open
    
    # Health check
    health_check_interval: float = 30.0    # Seconds between checks
    unhealthy_threshold: int = 3           # Consecutive failures
    
    # Behavior
    skip_encrypted: bool = True            # Skip encrypted files
    skip_on_error: bool = False            # Skip vs reject on error
    alert_on_skip: bool = True             # Alert when skipping


# Global configuration instance
CONFIG = ScannerConfig()
```

---

## 4. Main Scanning Function

```python
# =============================================================================
# MAIN SCANNING FUNCTION
# =============================================================================

async def scan_attachment(
    attachment: Attachment,
    config: ScannerConfig = CONFIG
) -> ScanResult:
    """
    Scan an email attachment for malware.
    
    This is the main entry point for the malware scanning step.
    
    Args:
        attachment: The attachment to scan
        config: Scanner configuration
    
    Returns:
        ScanResult with status and details
    
    Invariants:
        - Every attachment gets exactly one final status
        - Retries are transparent to caller
        - Circuit breaker prevents cascade failures
        - All failures are logged with correlation ID
    """
    
    # Generate correlation ID for tracing
    correlation_id = str(uuid.uuid4())
    
    # Create scan context
    context = ScanContext(
        attachment=attachment,
        attempt_number=0,
        max_attempts=config.max_retries,
        start_time=datetime.utcnow(),
        correlation_id=correlation_id,
        scanner_hosts=config.hosts.copy()
    )
    
    logger.info(
        f"[{correlation_id}] Starting malware scan for attachment "
        f"{attachment.id} ({attachment.filename}, {attachment.size_bytes} bytes)"
    )
    
    # ==========================================================================
    # PHASE 1: PRE-SCAN VALIDATION
    # ==========================================================================
    
    validation_result = await validate_attachment_for_scan(attachment, config)
    if validation_result is not None:
        # Validation failed, return early
        logger.info(
            f"[{correlation_id}] Pre-scan validation result: {validation_result.status}"
        )
        return validation_result
    
    # ==========================================================================
    # PHASE 2: SCAN WITH RETRY LOOP
    # ==========================================================================
    
    result = await scan_with_retry(context, config)
    
    # ==========================================================================
    # PHASE 3: POST-SCAN PROCESSING
    # ==========================================================================
    
    await post_scan_processing(attachment, result, context, config)
    
    logger.info(
        f"[{correlation_id}] Scan complete: {result.status.value} "
        f"(attempts: {context.attempt_number}, duration: {result.duration_ms}ms)"
    )
    
    return result
```

---

## 5. Pre-Scan Validation

```python
# =============================================================================
# PRE-SCAN VALIDATION
# =============================================================================

async def validate_attachment_for_scan(
    attachment: Attachment,
    config: ScannerConfig
) -> Optional[ScanResult]:
    """
    Validate attachment before scanning.
    
    Returns:
        ScanResult if validation fails (skip/reject), None if OK to scan
    """
    
    # --------------------------------------------------------------------------
    # CHECK 1: File size
    # --------------------------------------------------------------------------
    if attachment.size_bytes > config.max_file_size:
        logger.warning(
            f"Attachment {attachment.id} exceeds size limit: "
            f"{attachment.size_bytes} > {config.max_file_size}"
        )
        return ScanResult(
            status=ScanStatus.SKIPPED,
            error_code=ScanErrorCode.SIZE_EXCEEDED,
            error_message=f"File size {attachment.size_bytes} exceeds limit {config.max_file_size}",
            retry_decision=RetryDecision.SKIP_ATTACHMENT
        )
    
    # --------------------------------------------------------------------------
    # CHECK 2: Empty file
    # --------------------------------------------------------------------------
    if attachment.size_bytes == 0:
        logger.info(f"Attachment {attachment.id} is empty, marking as clean")
        return ScanResult(
            status=ScanStatus.CLEAN,
            error_message="Empty file"
        )
    
    # --------------------------------------------------------------------------
    # CHECK 3: Already scanned (idempotency)
    # --------------------------------------------------------------------------
    cached_result = await get_cached_scan_result(attachment.checksum_sha256)
    if cached_result is not None:
        logger.info(
            f"Attachment {attachment.id} already scanned (cache hit), "
            f"result: {cached_result.status}"
        )
        return cached_result
    
    # --------------------------------------------------------------------------
    # CHECK 4: Blocked file extension
    # --------------------------------------------------------------------------
    if is_blocked_extension(attachment.filename):
        logger.warning(
            f"Attachment {attachment.id} has blocked extension: {attachment.filename}"
        )
        return ScanResult(
            status=ScanStatus.INFECTED,
            virus_name="Heuristics.Blocked.Extension",
            error_message=f"Blocked file extension: {get_extension(attachment.filename)}",
            retry_decision=RetryDecision.REJECT_EMAIL
        )
    
    # --------------------------------------------------------------------------
    # CHECK 5: Encrypted file detection (optional skip)
    # --------------------------------------------------------------------------
    if config.skip_encrypted and is_encrypted_file(attachment.data):
        logger.info(
            f"Attachment {attachment.id} is encrypted, skipping scan"
        )
        return ScanResult(
            status=ScanStatus.SKIPPED,
            error_code=ScanErrorCode.ENCRYPTED_FILE,
            error_message="Encrypted file cannot be scanned",
            retry_decision=RetryDecision.SKIP_ATTACHMENT
        )
    
    # All validations passed
    return None


def is_blocked_extension(filename: str) -> bool:
    """Check if file extension is blocked."""
    BLOCKED_EXTENSIONS = {
        '.exe', '.bat', '.cmd', '.com', '.pif', '.scr',
        '.vbs', '.vbe', '.js', '.jse', '.ws', '.wsf',
        '.ps1', '.ps1xml', '.ps2', '.ps2xml', '.psc1', '.psc2',
        '.msh', '.msh1', '.msh2', '.mshxml', '.msh1xml', '.msh2xml',
        '.scf', '.lnk', '.inf', '.reg', '.dll', '.sys',
        '.cpl', '.msi', '.msp', '.hta', '.jar'
    }
    ext = get_extension(filename).lower()
    return ext in BLOCKED_EXTENSIONS


def get_extension(filename: str) -> str:
    """Extract file extension."""
    if '.' in filename:
        return '.' + filename.rsplit('.', 1)[-1]
    return ''


def is_encrypted_file(data: bytes) -> bool:
    """
    Detect if file is encrypted (heuristic).
    
    Checks:
      - Password-protected ZIP
      - Encrypted PDF
      - Encrypted Office documents
    """
    # ZIP with encryption flag
    if data[:2] == b'PK' and len(data) > 8:
        # Check general purpose bit flag for encryption
        if len(data) > 8 and (data[6] & 0x01):
            return True
    
    # PDF with /Encrypt
    if b'%PDF' in data[:1024] and b'/Encrypt' in data:
        return True
    
    # Office documents with EncryptedPackage
    if b'EncryptedPackage' in data[:4096]:
        return True
    
    return False


async def get_cached_scan_result(checksum: str) -> Optional[ScanResult]:
    """
    Get cached scan result by file checksum.
    
    Cache TTL: 24 hours for clean, 7 days for infected
    """
    cache_key = f"scan_result:{checksum}"
    
    cached = await redis.get(cache_key)
    if cached:
        return ScanResult(**json.loads(cached))
    
    return None
```

---

## 6. Retry Loop with Circuit Breaker

```python
# =============================================================================
# RETRY LOOP WITH CIRCUIT BREAKER
# =============================================================================

async def scan_with_retry(
    context: ScanContext,
    config: ScannerConfig
) -> ScanResult:
    """
    Execute scan with retry logic and circuit breaker.
    
    Retry Strategy:
      - Immediate retry for transient errors
      - Exponential backoff for overload
      - Different host for connection errors
      - No retry for permanent errors
    
    Circuit Breaker:
      - Opens after N consecutive failures
      - Half-open after timeout
      - Closes on successful scan
    """
    
    last_result: Optional[ScanResult] = None
    
    while context.attempt_number < context.max_attempts:
        context.attempt_number += 1
        
        # ----------------------------------------------------------------------
        # SELECT SCANNER HOST
        # ----------------------------------------------------------------------
        host = select_scanner_host(context, config)
        if host is None:
            logger.error(
                f"[{context.correlation_id}] No healthy scanner hosts available"
            )
            return ScanResult(
                status=ScanStatus.ERROR,
                error_code=ScanErrorCode.CONNECTION_REFUSED,
                error_message="No healthy scanner hosts available",
                retry_decision=RetryDecision.FAIL_PERMANENTLY
            )
        
        # ----------------------------------------------------------------------
        # CHECK CIRCUIT BREAKER
        # ----------------------------------------------------------------------
        if is_circuit_open(host):
            logger.warning(
                f"[{context.correlation_id}] Circuit breaker open for {host}, "
                f"trying next host"
            )
            mark_host_failed(host)
            context.current_host_index += 1
            continue
        
        # ----------------------------------------------------------------------
        # EXECUTE SCAN
        # ----------------------------------------------------------------------
        logger.info(
            f"[{context.correlation_id}] Attempt {context.attempt_number}/{context.max_attempts} "
            f"on host {host}"
        )
        
        result = await execute_single_scan(
            context.attachment,
            host,
            config,
            context.correlation_id
        )
        result.scanner_host = host
        last_result = result
        
        # ----------------------------------------------------------------------
        # HANDLE RESULT
        # ----------------------------------------------------------------------
        
        # Success cases - return immediately
        if result.status == ScanStatus.CLEAN:
            record_success(host)
            await cache_scan_result(context.attachment.checksum_sha256, result)
            return result
        
        if result.status == ScanStatus.INFECTED:
            record_success(host)
            await cache_scan_result(context.attachment.checksum_sha256, result)
            return result
        
        # Determine retry decision
        result.retry_decision = determine_retry_decision(result, context, config)
        
        # Handle based on retry decision
        if result.retry_decision == RetryDecision.FAIL_PERMANENTLY:
            logger.error(
                f"[{context.correlation_id}] Permanent failure: {result.error_code}"
            )
            record_failure(host)
            return result
        
        if result.retry_decision == RetryDecision.SKIP_ATTACHMENT:
            logger.warning(
                f"[{context.correlation_id}] Skipping attachment: {result.error_message}"
            )
            return result
        
        if result.retry_decision == RetryDecision.REJECT_EMAIL:
            logger.warning(
                f"[{context.correlation_id}] Rejecting email: {result.error_message}"
            )
            return result
        
        if result.retry_decision == RetryDecision.ALERT_AND_SKIP:
            logger.critical(
                f"[{context.correlation_id}] Alert triggered: {result.error_message}"
            )
            await send_alert(
                title="Malware Scan Alert",
                message=f"Scan failed for {context.attachment.filename}: {result.error_message}",
                severity="high"
            )
            return result
        
        # Retry cases
        record_failure(host)
        
        if result.retry_decision == RetryDecision.RETRY_DIFFERENT_HOST:
            context.current_host_index += 1
            logger.info(
                f"[{context.correlation_id}] Switching to different host"
            )
            # No delay, try next host immediately
            continue
        
        if result.retry_decision == RetryDecision.RETRY_BACKOFF:
            delay = calculate_backoff_delay(context.attempt_number, config)
            logger.info(
                f"[{context.correlation_id}] Backing off for {delay:.2f}s"
            )
            await asyncio.sleep(delay)
            continue
        
        if result.retry_decision == RetryDecision.RETRY_IMMEDIATE:
            logger.info(
                f"[{context.correlation_id}] Immediate retry"
            )
            continue
    
    # All retries exhausted
    logger.error(
        f"[{context.correlation_id}] All {context.max_attempts} attempts exhausted"
    )
    
    if last_result:
        last_result.retry_decision = RetryDecision.FAIL_PERMANENTLY
        return last_result
    
    return ScanResult(
        status=ScanStatus.ERROR,
        error_code=ScanErrorCode.INTERNAL_ERROR,
        error_message="All retry attempts exhausted",
        retry_decision=RetryDecision.FAIL_PERMANENTLY
    )


def select_scanner_host(context: ScanContext, config: ScannerConfig) -> Optional[str]:
    """
    Select a scanner host using round-robin with health awareness.
    """
    hosts = context.scanner_hosts
    start_index = context.current_host_index % len(hosts)
    
    # Try each host starting from current index
    for i in range(len(hosts)):
        index = (start_index + i) % len(hosts)
        host = hosts[index]
        
        health = get_host_health(host)
        if health.is_healthy:
            context.current_host_index = index
            return host
    
    # No healthy hosts, return least-failed host
    return min(hosts, key=lambda h: get_host_health(h).consecutive_failures)


def determine_retry_decision(
    result: ScanResult,
    context: ScanContext,
    config: ScannerConfig
) -> RetryDecision:
    """
    Determine retry decision based on error type.
    
    Decision Matrix:
    
    | Error Code          | Attempt 1      | Attempt 2      | Attempt 3      |
    |---------------------|----------------|----------------|----------------|
    | CONNECTION_REFUSED  | DIFFERENT_HOST | DIFFERENT_HOST | FAIL           |
    | CONNECTION_TIMEOUT  | DIFFERENT_HOST | BACKOFF        | FAIL           |
    | READ_TIMEOUT        | BACKOFF        | BACKOFF        | FAIL           |
    | WRITE_TIMEOUT       | IMMEDIATE      | BACKOFF        | FAIL           |
    | PROTOCOL_ERROR      | IMMEDIATE      | DIFFERENT_HOST | FAIL           |
    | SIZE_EXCEEDED       | SKIP           | -              | -              |
    | ENCRYPTED_FILE      | SKIP           | -              | -              |
    | CORRUPTED_FILE      | SKIP           | -              | -              |
    | SCANNER_OVERLOADED  | BACKOFF        | BACKOFF        | DIFFERENT_HOST |
    | DATABASE_NOT_LOADED | BACKOFF        | BACKOFF        | ALERT_SKIP     |
    | INTERNAL_ERROR      | IMMEDIATE      | BACKOFF        | FAIL           |
    """
    
    error_code = result.error_code
    attempt = context.attempt_number
    is_last_attempt = attempt >= context.max_attempts
    
    # Non-retryable errors
    if error_code in [
        ScanErrorCode.SIZE_EXCEEDED,
        ScanErrorCode.ENCRYPTED_FILE,
        ScanErrorCode.CORRUPTED_FILE
    ]:
        return RetryDecision.SKIP_ATTACHMENT
    
    # Last attempt - fail or alert
    if is_last_attempt:
        if error_code == ScanErrorCode.DATABASE_NOT_LOADED:
            return RetryDecision.ALERT_AND_SKIP
        return RetryDecision.FAIL_PERMANENTLY
    
    # Connection errors - try different host
    if error_code in [
        ScanErrorCode.CONNECTION_REFUSED,
        ScanErrorCode.CONNECTION_TIMEOUT
    ]:
        return RetryDecision.RETRY_DIFFERENT_HOST
    
    # Timeout errors - backoff
    if error_code in [
        ScanErrorCode.READ_TIMEOUT,
        ScanErrorCode.SCANNER_OVERLOADED
    ]:
        return RetryDecision.RETRY_BACKOFF
    
    # Write timeout - immediate retry first, then backoff
    if error_code == ScanErrorCode.WRITE_TIMEOUT:
        if attempt == 1:
            return RetryDecision.RETRY_IMMEDIATE
        return RetryDecision.RETRY_BACKOFF
    
    # Protocol error - immediate retry, then different host
    if error_code == ScanErrorCode.PROTOCOL_ERROR:
        if attempt == 1:
            return RetryDecision.RETRY_IMMEDIATE
        return RetryDecision.RETRY_DIFFERENT_HOST
    
    # Database not loaded - backoff (wait for reload)
    if error_code == ScanErrorCode.DATABASE_NOT_LOADED:
        return RetryDecision.RETRY_BACKOFF
    
    # Default - immediate retry
    return RetryDecision.RETRY_IMMEDIATE


def calculate_backoff_delay(attempt: int, config: ScannerConfig) -> float:
    """
    Calculate exponential backoff delay with jitter.
    
    Formula: min(base * 2^attempt + jitter, max_delay)
    """
    import random
    
    base_delay = config.retry_delay_base * (2 ** (attempt - 1))
    jitter = random.uniform(0, config.retry_jitter * base_delay)
    delay = min(base_delay + jitter, config.retry_delay_max)
    
    return delay
```

---

## 7. Single Scan Execution

```python
# =============================================================================
# SINGLE SCAN EXECUTION
# =============================================================================

async def execute_single_scan(
    attachment: Attachment,
    host: str,
    config: ScannerConfig,
    correlation_id: str
) -> ScanResult:
    """
    Execute a single scan attempt against a specific host.
    
    Protocol: ClamAV INSTREAM
    
    Steps:
      1. Connect to clamd
      2. Send INSTREAM command
      3. Send data in chunks
      4. Send end marker
      5. Read response
      6. Parse response
    """
    
    import socket
    import struct
    import time
    
    start_time = time.time()
    sock = None
    
    try:
        # ----------------------------------------------------------------------
        # STEP 1: CONNECT
        # ----------------------------------------------------------------------
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(config.connect_timeout)
        
        try:
            sock.connect((host, config.port))
        except socket.timeout:
            return ScanResult(
                status=ScanStatus.TIMEOUT,
                error_code=ScanErrorCode.CONNECTION_TIMEOUT,
                error_message=f"Connection timeout to {host}:{config.port}",
                duration_ms=(time.time() - start_time) * 1000
            )
        except socket.error as e:
            if e.errno == 111:  # Connection refused
                return ScanResult(
                    status=ScanStatus.CONNECTION_ERROR,
                    error_code=ScanErrorCode.CONNECTION_REFUSED,
                    error_message=f"Connection refused by {host}:{config.port}",
                    duration_ms=(time.time() - start_time) * 1000
                )
            raise
        
        logger.debug(f"[{correlation_id}] Connected to {host}:{config.port}")
        
        # ----------------------------------------------------------------------
        # STEP 2: SEND INSTREAM COMMAND
        # ----------------------------------------------------------------------
        sock.settimeout(config.write_timeout)
        
        try:
            sock.sendall(b"zINSTREAM\x00")
        except socket.timeout:
            return ScanResult(
                status=ScanStatus.TIMEOUT,
                error_code=ScanErrorCode.WRITE_TIMEOUT,
                error_message="Timeout sending INSTREAM command",
                duration_ms=(time.time() - start_time) * 1000
            )
        
        logger.debug(f"[{correlation_id}] Sent INSTREAM command")
        
        # ----------------------------------------------------------------------
        # STEP 3: SEND DATA IN CHUNKS
        # ----------------------------------------------------------------------
        data = attachment.data
        offset = 0
        chunks_sent = 0
        
        while offset < len(data):
            chunk = data[offset:offset + config.chunk_size]
            chunk_size = struct.pack(">I", len(chunk))  # Big-endian uint32
            
            try:
                sock.sendall(chunk_size + chunk)
            except socket.timeout:
                return ScanResult(
                    status=ScanStatus.TIMEOUT,
                    error_code=ScanErrorCode.WRITE_TIMEOUT,
                    error_message=f"Timeout sending chunk {chunks_sent + 1}",
                    duration_ms=(time.time() - start_time) * 1000
                )
            
            offset += len(chunk)
            chunks_sent += 1
        
        logger.debug(f"[{correlation_id}] Sent {chunks_sent} chunks ({len(data)} bytes)")
        
        # ----------------------------------------------------------------------
        # STEP 4: SEND END MARKER
        # ----------------------------------------------------------------------
        try:
            sock.sendall(b"\x00\x00\x00\x00")  # 4 bytes of zeros
        except socket.timeout:
            return ScanResult(
                status=ScanStatus.TIMEOUT,
                error_code=ScanErrorCode.WRITE_TIMEOUT,
                error_message="Timeout sending end marker",
                duration_ms=(time.time() - start_time) * 1000
            )
        
        logger.debug(f"[{correlation_id}] Sent end marker")
        
        # ----------------------------------------------------------------------
        # STEP 5: READ RESPONSE
        # ----------------------------------------------------------------------
        sock.settimeout(config.read_timeout)
        
        response = b""
        try:
            while True:
                chunk = sock.recv(1024)
                if not chunk:
                    break
                response += chunk
                if b"\x00" in response:
                    break
        except socket.timeout:
            return ScanResult(
                status=ScanStatus.TIMEOUT,
                error_code=ScanErrorCode.READ_TIMEOUT,
                error_message="Timeout reading scan response",
                duration_ms=(time.time() - start_time) * 1000
            )
        
        response_str = response.rstrip(b"\x00").decode("utf-8", errors="replace")
        logger.debug(f"[{correlation_id}] Received response: {response_str}")
        
        # ----------------------------------------------------------------------
        # STEP 6: PARSE RESPONSE
        # ----------------------------------------------------------------------
        duration_ms = (time.time() - start_time) * 1000
        return parse_clamav_response(response_str, duration_ms)
    
    except socket.error as e:
        return ScanResult(
            status=ScanStatus.ERROR,
            error_code=ScanErrorCode.CONNECTION_REFUSED,
            error_message=f"Socket error: {e}",
            duration_ms=(time.time() - start_time) * 1000
        )
    
    except Exception as e:
        logger.exception(f"[{correlation_id}] Unexpected error during scan")
        return ScanResult(
            status=ScanStatus.ERROR,
            error_code=ScanErrorCode.INTERNAL_ERROR,
            error_message=f"Unexpected error: {e}",
            duration_ms=(time.time() - start_time) * 1000
        )
    
    finally:
        if sock:
            try:
                sock.close()
            except:
                pass


def parse_clamav_response(response: str, duration_ms: float) -> ScanResult:
    """
    Parse ClamAV response string.
    
    Response formats:
      - "stream: OK" → clean
      - "stream: Eicar-Signature FOUND" → infected
      - "stream: <error> ERROR" → error
      - "INSTREAM size limit exceeded" → size error
    """
    
    response = response.strip()
    
    # --------------------------------------------------------------------------
    # CLEAN
    # --------------------------------------------------------------------------
    if response.endswith("OK"):
        return ScanResult(
            status=ScanStatus.CLEAN,
            duration_ms=duration_ms
        )
    
    # --------------------------------------------------------------------------
    # INFECTED
    # --------------------------------------------------------------------------
    if "FOUND" in response:
        # Extract virus name: "stream: Eicar-Signature FOUND"
        virus_name = "Unknown"
        if ":" in response:
            parts = response.split(":", 1)
            if len(parts) >= 2:
                virus_info = parts[1].strip()
                virus_name = virus_info.replace(" FOUND", "").strip()
        
        return ScanResult(
            status=ScanStatus.INFECTED,
            virus_name=virus_name,
            duration_ms=duration_ms
        )
    
    # --------------------------------------------------------------------------
    # SIZE LIMIT
    # --------------------------------------------------------------------------
    if "size limit" in response.lower():
        return ScanResult(
            status=ScanStatus.ERROR,
            error_code=ScanErrorCode.SIZE_EXCEEDED,
            error_message=response,
            duration_ms=duration_ms
        )
    
    # --------------------------------------------------------------------------
    # DATABASE NOT LOADED
    # --------------------------------------------------------------------------
    if "database" in response.lower() and "not" in response.lower():
        return ScanResult(
            status=ScanStatus.ERROR,
            error_code=ScanErrorCode.DATABASE_NOT_LOADED,
            error_message=response,
            duration_ms=duration_ms
        )
    
    # --------------------------------------------------------------------------
    # SCANNER OVERLOADED
    # --------------------------------------------------------------------------
    if "queue" in response.lower() or "overload" in response.lower():
        return ScanResult(
            status=ScanStatus.ERROR,
            error_code=ScanErrorCode.SCANNER_OVERLOADED,
            error_message=response,
            duration_ms=duration_ms
        )
    
    # --------------------------------------------------------------------------
    # GENERIC ERROR
    # --------------------------------------------------------------------------
    if "ERROR" in response:
        return ScanResult(
            status=ScanStatus.ERROR,
            error_code=ScanErrorCode.PROTOCOL_ERROR,
            error_message=response,
            duration_ms=duration_ms
        )
    
    # --------------------------------------------------------------------------
    # UNKNOWN RESPONSE
    # --------------------------------------------------------------------------
    return ScanResult(
        status=ScanStatus.ERROR,
        error_code=ScanErrorCode.PROTOCOL_ERROR,
        error_message=f"Unknown response: {response}",
        duration_ms=duration_ms
    )
```

---

## 8. Circuit Breaker Implementation

```python
# =============================================================================
# CIRCUIT BREAKER
# =============================================================================

# In-memory circuit breaker state (use Redis in production)
_circuit_state: Dict[str, dict] = {}


def get_circuit_state(host: str) -> dict:
    """Get circuit breaker state for a host."""
    if host not in _circuit_state:
        _circuit_state[host] = {
            "state": "closed",           # closed, open, half-open
            "failure_count": 0,
            "last_failure_time": None,
            "success_count": 0
        }
    return _circuit_state[host]


def is_circuit_open(host: str) -> bool:
    """
    Check if circuit breaker is open for a host.
    
    States:
      - CLOSED: Normal operation, requests allowed
      - OPEN: Failures exceeded threshold, requests blocked
      - HALF-OPEN: Testing if service recovered, limited requests
    """
    state = get_circuit_state(host)
    
    if state["state"] == "closed":
        return False
    
    if state["state"] == "open":
        # Check if timeout has passed
        if state["last_failure_time"]:
            elapsed = (datetime.utcnow() - state["last_failure_time"]).total_seconds()
            if elapsed >= CONFIG.circuit_breaker_timeout:
                # Transition to half-open
                state["state"] = "half-open"
                state["success_count"] = 0
                logger.info(f"Circuit breaker for {host} transitioning to half-open")
                return False
        return True
    
    if state["state"] == "half-open":
        # Allow limited requests in half-open state
        return False
    
    return False


def record_success(host: str):
    """Record successful scan for circuit breaker."""
    state = get_circuit_state(host)
    
    if state["state"] == "half-open":
        state["success_count"] += 1
        # Close circuit after 3 consecutive successes
        if state["success_count"] >= 3:
            state["state"] = "closed"
            state["failure_count"] = 0
            logger.info(f"Circuit breaker for {host} closed")
    else:
        state["failure_count"] = 0


def record_failure(host: str):
    """Record failed scan for circuit breaker."""
    state = get_circuit_state(host)
    state["failure_count"] += 1
    state["last_failure_time"] = datetime.utcnow()
    
    if state["state"] == "half-open":
        # Immediately open on failure in half-open state
        state["state"] = "open"
        logger.warning(f"Circuit breaker for {host} re-opened from half-open")
    elif state["failure_count"] >= CONFIG.circuit_breaker_threshold:
        state["state"] = "open"
        logger.warning(
            f"Circuit breaker for {host} opened after {state['failure_count']} failures"
        )


# =============================================================================
# HOST HEALTH TRACKING
# =============================================================================

_host_health: Dict[str, ScannerHealth] = {}


def get_host_health(host: str) -> ScannerHealth:
    """Get health status for a scanner host."""
    if host not in _host_health:
        _host_health[host] = ScannerHealth(
            host=host,
            port=CONFIG.port,
            is_healthy=True,
            last_check=datetime.utcnow(),
            consecutive_failures=0,
            avg_latency_ms=0.0
        )
    return _host_health[host]


def mark_host_failed(host: str):
    """Mark host as failed."""
    health = get_host_health(host)
    health.consecutive_failures += 1
    health.last_check = datetime.utcnow()
    
    if health.consecutive_failures >= CONFIG.unhealthy_threshold:
        health.is_healthy = False
        logger.warning(f"Host {host} marked unhealthy after {health.consecutive_failures} failures")


def mark_host_healthy(host: str, latency_ms: float):
    """Mark host as healthy."""
    health = get_host_health(host)
    health.is_healthy = True
    health.consecutive_failures = 0
    health.last_check = datetime.utcnow()
    
    # Update rolling average latency
    if health.avg_latency_ms == 0:
        health.avg_latency_ms = latency_ms
    else:
        health.avg_latency_ms = (health.avg_latency_ms * 0.9) + (latency_ms * 0.1)
```

---

## 9. Post-Scan Processing

```python
# =============================================================================
# POST-SCAN PROCESSING
# =============================================================================

async def post_scan_processing(
    attachment: Attachment,
    result: ScanResult,
    context: ScanContext,
    config: ScannerConfig
):
    """
    Process scan result after scanning completes.
    
    Actions:
      - Update attachment record
      - Cache result
      - Record metrics
      - Handle infected files
      - Send alerts if needed
    """
    
    # --------------------------------------------------------------------------
    # UPDATE ATTACHMENT RECORD
    # --------------------------------------------------------------------------
    attachment.scan_status = result.status
    attachment.scan_attempts = context.attempt_number
    attachment.last_scan_at = datetime.utcnow()
    attachment.virus_name = result.virus_name
    attachment.error_code = result.error_code
    attachment.error_message = result.error_message
    attachment.updated_at = datetime.utcnow()
    
    await update_attachment_in_db(attachment)
    
    # --------------------------------------------------------------------------
    # CACHE RESULT (for deduplication)
    # --------------------------------------------------------------------------
    if result.status in [ScanStatus.CLEAN, ScanStatus.INFECTED]:
        await cache_scan_result(attachment.checksum_sha256, result)
    
    # --------------------------------------------------------------------------
    # RECORD METRICS
    # --------------------------------------------------------------------------
    metrics.scan_total.labels(result=result.status.value).inc()
    metrics.scan_duration.observe(result.duration_ms / 1000)
    metrics.scan_bytes.observe(attachment.size_bytes)
    
    if result.error_code:
        metrics.scan_errors.labels(error_code=result.error_code.value).inc()
    
    # --------------------------------------------------------------------------
    # HANDLE INFECTED FILES
    # --------------------------------------------------------------------------
    if result.status == ScanStatus.INFECTED:
        await handle_infected_attachment(attachment, result, context)
    
    # --------------------------------------------------------------------------
    # SEND ALERTS
    # --------------------------------------------------------------------------
    if result.retry_decision == RetryDecision.ALERT_AND_SKIP:
        await send_alert(
            title="Malware Scan Failure",
            message=(
                f"Failed to scan attachment after {context.attempt_number} attempts.\n"
                f"Email ID: {attachment.email_id}\n"
                f"Attachment: {attachment.filename}\n"
                f"Error: {result.error_message}"
            ),
            severity="high"
        )


async def handle_infected_attachment(
    attachment: Attachment,
    result: ScanResult,
    context: ScanContext
):
    """
    Handle an infected attachment.
    
    Actions:
      - Quarantine the file
      - Log to security audit
      - Notify security team
      - Update email status
    """
    
    logger.warning(
        f"[{context.correlation_id}] INFECTED: {attachment.filename} "
        f"contains {result.virus_name}"
    )
    
    # Quarantine the attachment (move to secure storage)
    await quarantine_attachment(attachment)
    
    # Log to security audit trail
    await audit_log.log(
        event_type="malware_detected",
        email_id=attachment.email_id,
        attachment_id=attachment.id,
        filename=attachment.filename,
        virus_name=result.virus_name,
        checksum=attachment.checksum_sha256,
        correlation_id=context.correlation_id
    )
    
    # Notify security team
    await send_alert(
        title="Malware Detected",
        message=(
            f"Malware detected in email attachment.\n"
            f"Virus: {result.virus_name}\n"
            f"File: {attachment.filename}\n"
            f"Email ID: {attachment.email_id}\n"
            f"Checksum: {attachment.checksum_sha256}"
        ),
        severity="critical",
        channel="security"
    )


async def cache_scan_result(checksum: str, result: ScanResult):
    """
    Cache scan result for deduplication.
    
    TTL:
      - Clean: 24 hours
      - Infected: 7 days (longer to prevent re-scanning known malware)
    """
    cache_key = f"scan_result:{checksum}"
    
    ttl = 86400  # 24 hours for clean
    if result.status == ScanStatus.INFECTED:
        ttl = 604800  # 7 days for infected
    
    await redis.setex(
        cache_key,
        ttl,
        json.dumps({
            "status": result.status.value,
            "virus_name": result.virus_name,
            "cached_at": datetime.utcnow().isoformat()
        })
    )
```

---

## 10. Complete Flow Diagram

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    MALWARE SCANNING FLOW DIAGRAM                             │
└─────────────────────────────────────────────────────────────────────────────┘

                              ┌─────────────────┐
                              │  scan_attachment │
                              │    (entry)       │
                              └────────┬────────┘
                                       │
                                       ▼
                    ┌──────────────────────────────────────┐
                    │     PHASE 1: PRE-SCAN VALIDATION     │
                    ├──────────────────────────────────────┤
                    │  • Check file size                   │
                    │  • Check empty file                  │
                    │  • Check cache (idempotency)         │
                    │  • Check blocked extensions          │
                    │  • Check encrypted files             │
                    └────────────────┬─────────────────────┘
                                     │
                         ┌───────────┴───────────┐
                         │                       │
                    Validation OK           Validation FAIL
                         │                       │
                         │                       ▼
                         │              ┌─────────────────┐
                         │              │  Return early   │
                         │              │  (SKIP/REJECT)  │
                         │              └─────────────────┘
                         │
                         ▼
          ┌──────────────────────────────────────┐
          │      PHASE 2: SCAN WITH RETRY        │
          ├──────────────────────────────────────┤
          │                                      │
          │  ┌────────────────────────────────┐  │
          │  │      RETRY LOOP                │  │
          │  │  (max_attempts = 3)            │  │
          │  └───────────────┬────────────────┘  │
          │                  │                   │
          │                  ▼                   │
          │  ┌────────────────────────────────┐  │
          │  │  1. Select scanner host        │  │
          │  │     (round-robin + health)     │  │
          │  └───────────────┬────────────────┘  │
          │                  │                   │
          │                  ▼                   │
          │  ┌────────────────────────────────┐  │
          │  │  2. Check circuit breaker      │  │
          │  │     (open → try next host)     │  │
          │  └───────────────┬────────────────┘  │
          │                  │                   │
          │                  ▼                   │
          │  ┌────────────────────────────────┐  │
          │  │  3. Execute single scan        │  │
          │  │     (INSTREAM protocol)        │  │
          │  └───────────────┬────────────────┘  │
          │                  │                   │
          │      ┌───────────┴───────────┐       │
          │      │                       │       │
          │   SUCCESS                  FAILURE   │
          │      │                       │       │
          │      │                       ▼       │
          │      │       ┌────────────────────┐  │
          │      │       │ Determine retry    │  │
          │      │       │ decision           │  │
          │      │       └─────────┬──────────┘  │
          │      │                 │             │
          │      │     ┌───────────┼───────────┐ │
          │      │     │           │           │ │
          │      │  RETRY_*    SKIP/REJECT  FAIL │
          │      │     │           │           │ │
          │      │     │           │           │ │
          │      │     ▼           │           │ │
          │      │  ┌──────────┐   │           │ │
          │      │  │ Backoff/ │   │           │ │
          │      │  │ Switch   │   │           │ │
          │      │  │ host     │   │           │ │
          │      │  └────┬─────┘   │           │ │
          │      │       │         │           │ │
          │      │       └─────────┼───────────┘ │
          │      │                 │             │
          │      │            (loop back)        │
          │      │                               │
          └──────┼───────────────────────────────┘
                 │
                 ▼
    ┌──────────────────────────────────────┐
    │     PHASE 3: POST-SCAN PROCESSING    │
    ├──────────────────────────────────────┤
    │  • Update attachment record          │
    │  • Cache result                      │
    │  • Record metrics                    │
    │  • Handle infected (quarantine)      │
    │  • Send alerts                       │
    └────────────────┬─────────────────────┘
                     │
                     ▼
              ┌─────────────┐
              │   Return    │
              │  ScanResult │
              └─────────────┘
```

---

## 11. Failure Mode Summary

| Failure Mode | Error Code | Retry Decision | Max Retries | Notes |
|--------------|------------|----------------|-------------|-------|
| Connection refused | E001 | DIFFERENT_HOST | 3 | Try all hosts |
| Connection timeout | E002 | DIFFERENT_HOST | 3 | Try all hosts |
| Read timeout | E003 | BACKOFF | 3 | Exponential backoff |
| Write timeout | E004 | IMMEDIATE → BACKOFF | 3 | Quick retry first |
| Protocol error | E005 | IMMEDIATE → DIFFERENT_HOST | 3 | Quick retry first |
| Size exceeded | E006 | SKIP | 0 | No retry |
| Encrypted file | E007 | SKIP | 0 | No retry |
| Corrupted file | E008 | SKIP | 0 | No retry |
| Scanner overloaded | E009 | BACKOFF | 3 | Long backoff |
| Database not loaded | E010 | BACKOFF → ALERT | 3 | Alert on final failure |
| Internal error | E999 | IMMEDIATE → BACKOFF | 3 | Quick retry first |

---

## 12. Test Cases

```python
# =============================================================================
# TEST CASES
# =============================================================================

class TestMalwareScanning:
    """Test cases for malware scanning."""
    
    async def test_clean_file_scan(self):
        """Test scanning a clean file."""
        attachment = create_test_attachment(b"Hello, World!")
        result = await scan_attachment(attachment)
        
        assert result.status == ScanStatus.CLEAN
        assert result.virus_name is None
    
    async def test_infected_file_scan(self):
        """Test scanning an infected file (EICAR)."""
        eicar = b"X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*"
        attachment = create_test_attachment(eicar)
        result = await scan_attachment(attachment)
        
        assert result.status == ScanStatus.INFECTED
        assert "Eicar" in result.virus_name
    
    async def test_oversized_file_rejected(self):
        """Test that oversized files are skipped."""
        attachment = create_test_attachment(b"x" * (26 * 1024 * 1024))
        result = await scan_attachment(attachment)
        
        assert result.status == ScanStatus.SKIPPED
        assert result.error_code == ScanErrorCode.SIZE_EXCEEDED
    
    async def test_connection_refused_retry(self):
        """Test retry on connection refused."""
        with mock_scanner_down():
            attachment = create_test_attachment(b"test")
            result = await scan_attachment(attachment)
        
        assert result.status == ScanStatus.ERROR
        assert result.error_code == ScanErrorCode.CONNECTION_REFUSED
    
    async def test_timeout_retry_with_backoff(self):
        """Test retry with backoff on timeout."""
        with mock_scanner_slow(delay=60):
            attachment = create_test_attachment(b"test")
            result = await scan_attachment(attachment)
        
        assert result.status == ScanStatus.TIMEOUT
        assert result.error_code == ScanErrorCode.READ_TIMEOUT
    
    async def test_circuit_breaker_opens(self):
        """Test circuit breaker opens after failures."""
        host = "test-host"
        
        # Record failures
        for _ in range(CONFIG.circuit_breaker_threshold):
            record_failure(host)
        
        assert is_circuit_open(host) is True
    
    async def test_cached_result_returned(self):
        """Test cached result is returned."""
        attachment = create_test_attachment(b"cached content")
        
        # First scan
        result1 = await scan_attachment(attachment)
        
        # Second scan (should hit cache)
        result2 = await scan_attachment(attachment)
        
        assert result1.status == result2.status
    
    async def test_blocked_extension_rejected(self):
        """Test blocked extensions are rejected."""
        attachment = create_test_attachment(b"test", filename="malware.exe")
        result = await scan_attachment(attachment)
        
        assert result.status == ScanStatus.INFECTED
        assert result.virus_name == "Heuristics.Blocked.Extension"
```

---

**This is the technical truth. Implement it exactly.** 🎯
